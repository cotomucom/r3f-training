# Chapter 2 — クリックで選択する

前の章で、3 つの立方体を state から描画できるようになりました。しかし今のままでは、どの立方体をクリックしても何も起きません。回転させたり削除したりする前に、まず「どれを操作するのか」を決める仕組みが必要です。この章では、クリックで立方体を選択し、選択中のオブジェクトの見た目を変える機能を実装します。


## 選択状態を state で管理する

「今どのオブジェクトが選択されているか」を表現するには、選択中のオブジェクトの ID を state に持てば十分です。何も選択されていない状態は `null` で表します。

`objects` の state 定義の直後に、以下を追加してください。

```tsx
const [selectedId, setSelectedId] = useState<string | null>(null);
```

型が `string | null` になっているのは、「選択中」と「未選択」の両方を自然に表現するためです。数値のインデックスで管理する方法もありますが、おすすめしません。オブジェクトを削除するとインデックスがずれて、意図しないオブジェクトが選択状態になる事故が起きるからです。ID であれば、他のオブジェクトが増減しても影響を受けません。

UI に選択中のオブジェクト名を表示するために、以下の導出値も用意しておきましょう。

```tsx
const selectedObject = objects.find((obj) => obj.id === selectedId) ?? null;
```

`objects.find(...)` で `selectedId` と一致するオブジェクトを探し、見つからなければ `null` を返します。これで「選択中: Cube A」のような表示が簡単にできます。


## メッシュにクリックイベントを追加する

次に、立方体をクリックしたときに `selectedId` を更新する処理を追加します。前の章で書いた `<mesh>` に `onPointerDown` を追加してください。

```tsx
<mesh
  key={obj.id}
  position={obj.position}
  rotation={obj.rotation}
  onPointerDown={(event) => {
    event.stopPropagation();
    setSelectedId(obj.id);
  }}
>
```

R3F の `<mesh>` は、DOM 要素と同じようにポインターイベントを受け取れます。`onPointerDown` はマウスボタンを押した瞬間に発火します。

ここで重要なのが `event.stopPropagation()` です。R3F のイベントシステムでは、レイキャスト（マウス位置から 3D 空間に光線を飛ばして何に当たるか調べる処理）によって複数のオブジェクトがヒットすることがあります。たとえば立方体が重なっていると、手前の立方体だけでなく奥の立方体にもイベントが伝播します。`stopPropagation()` を呼ぶことで、手前のオブジェクトだけがイベントを受け取り、背面のオブジェクトには伝わらなくなります。


## 背景クリックで選択を解除する

立方体の選択ができたら、何もない場所をクリックしたときに選択を解除する処理も入れましょう。`<Canvas>` に `onPointerMissed` を追加します。

```tsx
<Canvas
  camera={{ position: [6, 6, 10], fov: 50 }}
  onPointerMissed={() => {
    setSelectedId(null);
  }}
>
```

これで、立方体をクリックすれば選択され、背景をクリックすれば解除される、という自然な操作フローができあがります。


## 選択中のオブジェクトを視覚的に区別する

選択状態が state にあるだけでは、画面上で何が起きているのかわかりません。選択中の立方体の見た目を変えて、ユーザーに視覚的なフィードバックを与えましょう。

`<meshStandardMaterial>` の `emissive` プロパティを使います。

```tsx
<meshStandardMaterial
  color={obj.color}
  emissive={obj.id === selectedId ? "#222222" : "#000000"}
/>
```

`emissive` は「自己発光色」です。ライトに関係なくオブジェクト自体が放つ色で、`#000000`（黒）なら発光なし、`#222222` なら微量の白い発光が加わります。これにより、選択中の立方体がわずかに明るく見えるようになります。

`color` を直接変えてしまうと元の色がわからなくなりますが、`emissive` なら元の色を保ったまま「選択されている感」を出せます。


## 動作確認

ブラウザで以下を確認してください。

- 立方体をクリックすると、その立方体だけが少し明るくなる
- 別の立方体をクリックすると、前の選択が解除されて新しいものが明るくなる
- 背景（立方体がない場所）をクリックすると、すべての選択が解除される

もしクリックしても何も変化しない場合は、`emissive` の条件式 `obj.id === selectedId` が正しく評価されているか確認してください。`===` が `=` になっていないか、`obj.id` と `selectedId` の型が合っているか（両方 `string` か）を見直してみましょう。


## ここまでのコード構造

この章で追加したのは以下の 3 点だけです。

1. `selectedId` という state を 1 つ追加した
2. `<mesh>` のクリックで `setSelectedId(obj.id)` を呼ぶようにした
3. `emissive` で選択中かどうかを視覚的に表現した

state を 1 つ追加するだけでインタラクションが生まれる——この手軽さが、React の state 管理と R3F の宣言的な描画を組み合わせる利点です。次の章では、この選択機能を土台にして、選択中のオブジェクトを回転・削除できるようにします。


## 練習

- 選択中の立方体のスケールを `[1.1, 1.1, 1.1]` に変えてみてください。`<mesh>` の `scale` prop に三項演算子で条件分岐を入れれば実現できます。選択が見た目でさらにわかりやすくなります。
- `<Canvas>` の直上に `<p>選択中: {selectedObject?.name ?? "なし"}</p>` を追加してみてください。3D の状態と UI の表示が同じ state から導出されていることが実感できるはずです。
