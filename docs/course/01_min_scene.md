# Chapter 1 — 最小のシーンを表示する

いよいよコードを書き始めます。この章のゴールは「ブラウザに 3 つの立方体を表示すること」です。地味に見えますが、ここで作る構造がこの先すべての機能の土台になります。

これ以降のコードはすべて `src/pages/Playground.tsx` に書いていきます。


## Canvas — R3F の入り口

R3F で 3D シーンを表示するには、まず `<Canvas>` コンポーネントをインポートするところから始まります。`<Canvas>` は R3F の最も基本的なコンポーネントで、内部で three.js の Scene、Camera、Renderer をすべて生成し、アニメーションループの管理も自動で行ってくれます。

`Playground.tsx` のファイル冒頭に以下の import 文を追加してください。

```tsx
import { Canvas } from "@react-three/fiber";
```

次に、コンポーネントの `return` の中にある `canvas-wrap` の `div` の中に `<Canvas>` を配置します。

```tsx
<div className="canvas-wrap">
  <Canvas camera={{ position: [6, 6, 10], fov: 50 }}>
    {/* ここに 3D コンテンツを書いていく */}
  </Canvas>
</div>
```

`camera` prop でカメラの初期位置と視野角（fov: field of view）を指定しています。`[6, 6, 10]` は「右に 6、上に 6、手前に 10」の位置で、斜め上からシーンを見下ろす視点です。`fov: 50` は人間の視野に近い自然な画角です。

この時点でブラウザを確認すると、真っ暗な領域だけが表示されるはずです。Canvas は用意できたけれど、まだ何も置いていないので当然です。ここから順にシーンの中身を作っていきます。

`<Canvas>` は親要素のサイズに合わせて描画領域を確保する仕組みになっています。もし何も表示されない場合は、親の `div` に高さがあるか確認してください（このプロジェクトでは `canvas-wrap` クラスに適切な高さが設定済みです）。


## オブジェクトのデータ構造を決める

Canvas の準備ができたら、次は「3D シーンに存在するオブジェクト」をどんなデータとして表現するかを決めましょう。Chapter 0 で確認した通り、R3F では React の state がデータの正解になります。描画はそこから導出されるだけなので、state の設計がそのままアプリケーションの設計になります。

このコースで扱うオブジェクトには、以下の情報が必要です。

- **id** — オブジェクトを一意に識別するための文字列。後で選択や削除の対象を特定するのに使います。
- **name** — UI に表示するための名前。
- **color** — 立方体の色。
- **position** — 3D 空間上の座標 `[x, y, z]`。
- **rotation** — 各軸の回転角度 `[x, y, z]`（ラジアン）。

これを TypeScript の型として定義しましょう。`Playground.tsx` の import 文の直下に書きます。

```tsx
export type SceneObject = {
  id: string;
  name: string;
  color: string;
  position: [number, number, number];
  rotation: [number, number, number];
};
```

`position` と `rotation` の型が `[number, number, number]` という 3 要素のタプルになっている点に注目してください。three.js は 3D 座標を `[x, y, z]` で扱うので、要素数が固定であることを型で保証しておくと、うっかり 2 要素しか渡さなかった、といったミスをコンパイル時に弾けます。


## 初期オブジェクトを state に入れる

型が決まったら、コンポーネントの中で state を定義します。`useState` を React からインポートして、まずは立方体を 3 つ、`Playground()` の中で座標をずらしながら定義してみましょう。

```tsx
import { useState } from "react";
```

```tsx
const [objects, setObjects] = useState<SceneObject[]>([
  { id: "a", name: "Cube A", color: "#ff8c61", position: [-2, 0.5, 0], rotation: [0, 0, 0] },
  { id: "b", name: "Cube B", color: "#5fa8ff", position: [0, 0.5, 0],  rotation: [0, 0, 0] },
  { id: "c", name: "Cube C", color: "#f9d65c", position: [2, 0.5, 0],  rotation: [0, 0, 0] },
]);
```

各オブジェクトの `position` で `y` が `0.5` になっていることに気づきましたか？ 座標はオブジェクトの**中心**を指します。立方体のサイズを後で一辺 1 で定義しますが、そのとき `y=0` だと立方体の下半分が地面にめり込んでしまうので、半分の高さだけ持ち上げて `y=0.5` にしています。

`setObjects` はこの時点ではまだ使いませんが、消さずに残しておいてください。次の章から頻繁に使うことになります。


## ライトを追加する

`<Canvas>` の中に立方体を置く前に、ライトを設置しましょう。three.js ではライトがないとオブジェクトが真っ黒に表示されます（`meshBasicMaterial` を使えばライト不要ですが、立体感がなくなるので通常は使いません）。

このコースでは 2 種類のライトを組み合わせます。

```tsx
<ambientLight intensity={0.6} />
<directionalLight position={[5, 8, 3]} intensity={0.8} />
```

**ambientLight** は空間全体を均一に照らす光です。どの角度からも同じ明るさなので影ができません。これだけだとオブジェクトがのっぺり見えますが、真っ黒になる面をなくす役割があります。

**directionalLight** は特定の方向から差す平行光線です。太陽光に近いイメージで、オブジェクトに陰影を作ります。`position` はライトの「向き」を決めるもので、`[5, 8, 3]` は右上奥から光が差す配置です。

この 2 つを組み合わせることで、「全体が暗くなりすぎず、かつ立体感が出る」ライティングになります。


## グリッドを敷く

空間の基準面を可視化するために、グリッドを追加します。

```tsx
<gridHelper args={[20, 20, "#3b3b3b", "#2a2a2a"]} />
```

`args` は three.js の `GridHelper` コンストラクタに渡す引数で、順に「サイズ」「分割数」「中心線の色」「グリッド線の色」です。20×20 のグリッドが地面に広がり、オブジェクトがどこにいるかが掴みやすくなります。


## state からメッシュを描画する

すべての部品が揃ったので、state に入れた 3 つのオブジェクトを 3D シーン上に描画しましょう。

```tsx
{objects.map((obj) => (
  <mesh key={obj.id} position={obj.position} rotation={obj.rotation}>
    <boxGeometry args={[1, 1, 1]} />
    <meshStandardMaterial color={obj.color} />
  </mesh>
))}
```

`<mesh>` は three.js の `Mesh` に対応するコンポーネントで、3D オブジェクトの本体です。内部に **geometry**（形状）と **material**（素材・見た目）を持ちます。

`<boxGeometry args={[1, 1, 1]} />` は一辺 1 の立方体の形状を定義しています。`<meshStandardMaterial>` はライトに反応する標準的なマテリアルで、`color` に各オブジェクトの色を渡しています。

`objects.map(...)` で配列の各要素をコンポーネントに変換する——これは React でリストを描画するときのいつものパターンです。3D でも同じやり方が使えるのが R3F の良いところです。`key` には `obj.id` を使っています。


## 動作確認

ブラウザに以下が表示されていれば成功です。

- 色違いの立方体が 3 つ横並びに表示されている
- グリッドが地面に広がっている
- 立方体にライトによる陰影がついている

もし何も表示されない場合は、`<Canvas>` の親要素に高さがあるか確認してください。`<Canvas>` は親要素のサイズに合わせて描画領域を確保するため、親の高さが 0 だと何も見えません。

立方体が真っ黒で表示されている場合は、ライトのコードが `<Canvas>` の**中**にあるか確認してください。`<Canvas>` の外に書いても three.js には渡りません。


## この章で作ったものの意味

ここで書いたコードは少量ですが、重要な構造を含んでいます。

1. **state にオブジェクト配列を持つ**: これが「正解データ」になる
2. **`objects.map()` で描画する**: state と描画が連動する
3. **個々のオブジェクトは `id` で識別する**: 次章以降の選択・更新・削除の基盤

次の章では、この立方体をクリックして「選択」する機能を追加します。


## 練習

- 立方体を 4 つに増やして、1 つだけ `y=1.5` に置いてみてください。空中に浮いているように見えるはずです。
- `directionalLight` の `position` を `[0, 8, 0]` に変えてみてください。真上からの光に変わり、陰影のつき方が変わるのが観察できます。
- `ambientLight` を消して（行をコメントアウトして）みてください。ライトの当たらない面が真っ黒になるので、ambientLight の役割が体感できます。
