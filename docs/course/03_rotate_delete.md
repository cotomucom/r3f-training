# Chapter 3 — 回転と削除

ここまでで、立方体の選択ができるようになりました。この章では、選択中のオブジェクトに対する「回転」と「削除」の操作を追加します。

新しい概念はほとんど登場しません。React の `map` と `filter` でイミュータブル（元データは壊さず、新しいデータを作って差し替える）に state を更新するパターンの応用です。


## 回転を実装する

選択中のオブジェクトを Y 軸（縦軸）方向に 30 度回転させる関数を書きます。`selectedObject` の定義の下あたりに追加してください。

```tsx
const rotateSelected = () => {
  if (!selectedId) return;

  setObjects((prev) =>
    prev.map((obj) =>
      obj.id === selectedId
        ? {
            ...obj,
            rotation: [obj.rotation[0], obj.rotation[1] + Math.PI / 6, obj.rotation[2]],
          }
        : obj
    )
  );
};
```

処理の流れを追ってみましょう。

まず、`selectedId` が `null` なら何もしません。何も選択されていないのに回転を試みても意味がないので、早期リターンで弾きます。

`setObjects` に渡している関数では、`prev.map(...)` で全オブジェクトを走査し、`selectedId` と一致するオブジェクトだけ `rotation` の Y 成分（2 番目の要素）に `Math.PI / 6`（30 度）を加算します。一致しないオブジェクトはそのまま返します。

30 度という値に深い理由はありません。ボタンを押したときに「回った！」と視認できる程度の角度です。`Math.PI / 6` は three.js の回転がラジアン単位であるため、度数法の 30 度をラジアンに変換した値です。

ここで `obj.rotation[1] += Math.PI / 6` のように直接代入してはいけません。今回のように `map` で新しい配列を返していても、要素の中身を破壊的に変更すると「前の state と次の state の境界」が曖昧になり、後続処理で意図しない副作用を生みやすくなります。必ず新しい配列 `[obj.rotation[0], obj.rotation[1] + Math.PI / 6, obj.rotation[2]]` を作って返してください。


## 回転ボタンを追加する

関数を作っただけでは実行できないので、UI にボタンを追加します。`<Canvas>` の上（または下）に、操作パネルを作りましょう。

```tsx
<div>
  <div className="info">
    <p>選択中: {selectedObject?.name ?? "なし"}</p>
  </div>

  <div className="controls">
    <button onClick={rotateSelected}>
      選択を回転 (+30°)
    </button>
  </div>
</div>
```

選択状態を表示する `info` と、操作ボタンを配置する `controls` に分けています。ボタンの `onClick` に `rotateSelected` 関数を渡すことで、クリック時に選択中の立方体が回転します。


## 回転の動作確認

ブラウザで以下を確認してください。

- 立方体を選択して「選択を回転」ボタンを押すと、選択中の立方体だけが 30 度ずつ回転する
- 回転を何度押しても問題なく累積していく
- 選択されていないときにボタンを押しても何も起きない
- 回転しなかった立方体は影響を受けていない

全オブジェクトが回転してしまう場合は、`obj.id === selectedId` 条件が抜けています。回転しても見た目が変わらない場合は、`rotation` の Y 成分(インデックス `1`)ではなく別の成分を変更している可能性があります。


## 削除を実装する

回転が動作することを確認したら、次は削除機能を追加します。選択中のオブジェクトを state から取り除く関数を、`rotateSelected` の下に追加してください。

```tsx
const deleteSelected = () => {
  if (!selectedId) return;

  setObjects((prev) => prev.filter((obj) => obj.id !== selectedId));
  setSelectedId(null);
};
```

`filter` で `selectedId` と一致**しない**オブジェクトだけを残した新しい配列を作っています。一致するオブジェクトは新しい配列に含まれないので、結果として削除されます。

`setSelectedId(null)` でリセットしている点が大事です。これを忘れると、「すでに存在しないオブジェクトの ID が選択状態として残っている」という不整合が起きます。UI に選択名を表示している場合、`objects.find(...)` が `undefined` を返すことになり、表示がおかしくなります。

回転では `map` を使い、削除では `filter` を使いました。どちらも配列を新しく作って返すメソッドですが、意図が異なります。

- **`map`** — 要素数は変えずに、特定の要素の中身を変更する
- **`filter`** — 中身は変えずに、条件に合わない要素を取り除く

この使い分けを意識しておくと、state 更新のロジックが読みやすくなります。


## 削除ボタンを追加する

削除を実行するためのボタンを、回転ボタンの横に追加します。

```tsx
<div className="controls">
  <button onClick={rotateSelected}>
    選択を回転 (+30°)
  </button>
  <button onClick={deleteSelected}>選択を削除</button>
</div>
```

`deleteSelected` 関数も内部で `if (!selectedId) return;` しているので、何も選択されていない状態でボタンを押しても何も起きません。


## 削除の動作確認

ブラウザで以下を確認してください。

- 「選択を削除」ボタンを押すと、選択中の立方体が消える
- 削除後に UI の「選択中」表示が「なし」に戻る
- 削除しなかった立方体は影響を受けていない

削除後もオブジェクト名が UI に残り続ける場合は、`setSelectedId(null)` が呼ばれていない可能性があります。全オブジェクトが削除されてしまう場合は、`filter` の条件が逆(`obj.id === selectedId`)になっています。


## ここまでの振り返り

Chapter 1 から 3 で実装した機能を振り返ると、すべて同じパターンに従っています。

| 機能 | state | 更新方法 |
|---|---|---|
| 表示 | `objects` | 初期値を設定 |
| 選択 | `selectedId` | クリックで ID を設定 |
| 回転 | `objects[].rotation` | `map` で対象だけ角度を加算 |
| 削除 | `objects` | `filter` で対象を除外 |

「state を更新すれば画面が変わる」という原則だけで、ここまでの機能が実現できています。  
次の章では `@react-three/drei` を導入して、カメラ操作とドラッグ移動を追加します。drei は R3F の上に「よく使う部品」を集めたライブラリで、手書きすると複雑になる処理をコンポーネント一つで実現できます。


## 練習

- 回転量を `Math.PI / 12`（15 度）や `Math.PI / 4`（45 度）に変えて、操作感の違いを比べてみてください。
- 削除ボタンを押す前に `window.confirm("本当に削除しますか？")` で確認ダイアログを出してみてください。`confirm` が `false` を返したら早期リターンするだけです。
- X 軸方向の回転ボタンを追加してみてください。`rotation[0]` に加算すれば、立方体が前後に倒れるように回ります。
